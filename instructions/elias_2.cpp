#include <iostream>
#include <string>

bool is_sum_zero(int ar[], int n) {
	int s = 0;
	for (int i = 0; i < n; i++) {
		s += ar[i];
	}
	return s == 0;
}

int main() {
	int array[100]; //так объявляется массив из 100 элементов. Размер массива должен быть константой.

	//Массив нельзя уменьшить или увеличить.
	//Можно объявить двумерный массив:

	bool other_array[100][100];

	// Можно обращаться к элементам массива и изменять их. Причём обращение к элементу массива происходит,
	// в отличие от Питона, за О(1). Массивы в С++ и списки в Питоне устроены принципиально по-разному.

	array[7] = 10;
	array[8] = 11;
	std::cout << array[7] + array[8] << std::endl;

	// Теперь строки.
	std::string str = "Hello!";
	std::cout << str[0] << std::endl;

	std::string other_str;
	std::cin >> other_str;
	std::cout << other_str + other_str << std::endl;


	//Выше объявлена функция, которая принимает на вход массив. Обратите внимание на синтаксис.
	//Возвращать массивы из функций нельзя. Важная особенность передачи массива -- он не копируется.
	//То есть если мы передали, например, int, и присвоили ему что-то -- снаружи его значение не изменится.
	//А если мы передали массив целых чисел и присвоили что-то к-му элементу, то он изменится снаружи.

	//Задание. Прочитайте в Википедии статью про алгоритм Вагнера-Фишера. [https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0]
	//Реализуйте его. Все штрафы единичные; реализация должна представлять из себя функцию 
	//int levenstein(std::string a, std::string b, int matrix[][]);
	//Функция должна возвращать расстояние Левенштейна между строками и заполнять матрицу, которая образуется в процессе работы.

	system("pause");
	return 0;
}